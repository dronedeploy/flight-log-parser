{"version":3,"file":"flight-log-parser.es6.js","sources":["../src/types.ts","../node_modules/csv-parse/lib/index.js","../src/field-types.ts","../src/parser.ts"],"sourcesContent":["export enum FlightLogHeader {\n  DateTime = 'Date/Time (UTC)',\n  ElapsedTime = 'Elapsed Time (sec)',\n  Info = 'Info',\n  DeviceLatitude = 'Device Latitude (Degrees)',\n  DeviceLongitude = 'Device Longitude (Degrees)',\n  DeviceLocationLastUpdated = 'Device Location Last Updated (ms)',\n  AircraftBatteryPowerPercent = 'Aircraft Battery Power (%)',\n  AircraftBatteryCharge = 'Aircraft Battery Charge (mAh)',\n  AircraftBatteryCurrent = 'Aircraft Battery Current (mA)',\n  AircraftBatteryVoltage = 'Aircraft Battery Voltage (mV)',\n  AircraftBatteryTemperature = 'Aircraft Battery Temperature (Fahrenheit)',\n  AircraftBatteryLastUpdated = 'Aircraft Battery Last Updated (ms)',\n  AircraftBatteryCell1Voltage = 'Aircraft Battery Cell 1 Voltage',\n  AircraftBatteryCell2Voltage = 'Aircraft Battery Cell 2 Voltage',\n  AircraftBatteryCell3Voltage = 'Aircraft Battery Cell 3 Voltage',\n  AircraftBatteryCell4Voltage = 'Aircraft Battery Cell 4 Voltage',\n  AircraftBatteryCellVoltageLastUpdated = 'Aircraft Battery Cell Voltage Last Updated (ms)',\n  AircraftLatitude = 'Aircraft Latitude (Degrees)',\n  AircraftLongitude = 'Aircraft Longitude (Degrees)',\n  AircraftSpeed = 'Aircraft Speed (mph)',\n  AircraftBarometricAltitude = 'Aircraft Barometric Altitude (ft)',\n  AircraftHeading = 'Aircraft Heading (Degrees)',\n  AircraftVelocityX = 'Aircraft Vel - X (mph)',\n  AircraftVelocityY = 'Aircraft Vel - Y (mph)',\n  AircraftVelocityZ = 'Aircraft Vel - Z (mph)',\n  AircraftPitch = 'Aircraft Pitch (Degrees)',\n  AircraftRoll = 'Aircraft Roll (Degrees)',\n  AircraftSatellites = 'Aircraft Satellites',\n  AircraftMotorsOn = 'Aircraft Motors On',\n  AircraftFlying = 'Aircraft Flying',\n  AircraftFlightMode = 'Aircraft Flight Mode',\n  AircraftFlightModeValue = 'Aircraft Flight Mode Value',\n  AircraftIMUPreheating = 'Aircraft IMU Preheating',\n  AircraftUltrasonicOn = 'Aircraft Ultrasonic On',\n  AircraftUltrasonicAltitude = 'Aircraft Ultrasonic Altitude (ft)',\n  AircraftVisionOn = 'Aircraft Vision On',\n  AircraftGPSSignal = 'Aircraft GPS Signal',\n  AircraftGPSSignalValue = 'Aircraft GPS Signal Value',\n  AircraftNoFly = 'Aircraft No-fly',\n  AircraftNoFlyValue = 'Aircraft No-fly Value',\n  AircraftNoFlyLatitude = 'Aircraft No-fly Latitude (Degrees)',\n  AircraftNoFlyLongitude = 'Aircraft No-fly Longitude (Degrees)',\n  AircraftNoFlyRadius = 'Aircraft No-fly Radius (ft)',\n  HomeLatitude = 'Home Latitude (Degrees)',\n  HomeLongitude = 'Home Longitude (Degrees)',\n  AircraftSmartGoHomeFlightTimeRemaining = 'Aircraft Smart Go-home Flight Time Remaining (sec)',\n  AircraftSmartGoHomeFlightReturnTime = 'Aircraft Smart Go-home Flight Return Time (sec)',\n  AircraftSmartGoHomeLandingTime = 'Aircraft Smart Go-home Landing Time (sec)',\n  AircraftSmartGoHomeReturnPower = 'Aircraft Smart Go-home Return Power (%)',\n  AircraftSmartGoHomeLandingPower = 'Aircraft Smart Go-home Landing Power (%)',\n  AircraftSmartGoHomeRadius = 'Aircraft Smart Go-home Radius (ft)',\n  AircraftSmartGoHomeCountdown = 'Aircraft Smart Go-home Countdown (sec)',\n  AircraftSmartGoHomeRequesting = 'Aircraft Smart Go-home Requesting',\n  AircraftSystemStateLastUpdated = 'Aircraft System State Last Updated (ms)',\n  GimbalPitch = 'Gimbal Pitch (Degrees)',\n  GimbalRoll = 'Gimbal Roll (Degrees)',\n  GimbalYaw = 'Gimbal Yaw (Degrees)',\n  GimbalMode = 'Gimbal Mode',\n  GimbalModeValue = 'Gimbal Mode Value',\n  GimbalPitchAtStop = 'Gimbal Pitch at Stop',\n  GimbalRollAtStop = 'Gimbal Roll at Stop',\n  GimbalYawAtStop = 'Gimbal Yaw at Stop',\n  GimbalStatusLastUpdated = 'Gimbal Status Last Updated (ms)',\n  LandingGearIsMovable = 'Landing Gear is Movable',\n  LandingGearStatus = 'Landing Gear Status',\n  LandingGearStatusValue = 'Landing Gear Status Value',\n  LandingGearMode = 'Landing Gear Mode',\n  LandingGearModeValue = 'Landing Gear Mode Value',\n  LandingGearLastUpdated = 'Landing Gear Last Updated (ms)',\n  RCState = 'RC State',\n  RCStateValue = 'RC State Value',\n  RCLeftHorizontal = 'RC Left Horizontal',\n  RCLeftVertical = 'RC Left Vertical',\n  RCRightHorizontal = 'RC Right Horizontal',\n  RCRightVertical = 'RC Right Vertical',\n  RCLeftWheel = 'RC Left Wheel',\n  RCRightWheel = 'RC Right Wheel',\n  RCLandingGear = 'RC Landing Gear',\n  RCLandingGearValue = 'RC Landing Gear Value',\n  RCGoHome = 'RC Go Home',\n  RCRecord = 'RC Record ',\n  RCShutter = 'RC Shutter',\n  RCPlayback = 'RC Playback',\n  RCPause = 'RC Pause',\n  RCCustom1 = 'RC Custom 1',\n  RCCustom2 = 'RC Custom 2',\n  RCStateLastUpdated = 'RC State Last Updated (ms)',\n  RCBatteryPercentRemaining = 'RC Battery (%)',\n  RCBatteryStateLastUpdated = 'RC Battery State Last Updated (ms)',\n  RCSattelites = 'RC Sattelites',\n  RCHorizontalAccuaracy = 'RC Horizontal Accuaracy (ft)',\n  RCLatitude = 'RC Latitude (Degrees)',\n  RCLongitude = 'RC Longitude (Degrees)',\n  RCGSPDataIsValid = 'RC GSP Data is Valid',\n  RCGPSStateLastUpdated = 'RC GPS State Last Updated (ms)',\n  RCSignal1 = 'RC Signal 1',\n  RCSignal2 = 'RC Signal 2',\n  RCSignalLastUpdated = 'RC Signal Last Updated (ms)',\n  LBSignal1 = 'LB Signal 1',\n  LBSignal2 = 'LB Signal 2',\n  LBSignalLastUpdated = 'LB Signal Last Updated (ms)',\n  AircraftCameraMode = 'Aircraft Camera Mode',\n  AircraftCameraModeValue = 'Aircraft Camera Mode Value',\n  AircraftCameraOverheated = 'Aircraft Camera Overheated',\n  AircraftCameraSensorError = 'Aircraft Camera Sensor Error',\n  AircraftCameraRecording = 'Aircraft Camera Recording',\n  AircraftCameraRawCapture = 'Aircraft Camera Raw Capture',\n  AircraftCameraIntervalCapture = 'Aircraft Camera Interval Capture',\n  AircraftCameraBurstCapture = 'Aircraft Camera Burst Capture',\n  AircraftCameraSingleCapture = 'Aircraft Camera Single Capture',\n  AircraftCameraStoringPhoto = 'Aircraft Camera Storing Photo',\n  AircraftCameraStateLastUpdated = 'Aircraft Camera State Last Updated (ms)',\n  AircraftCameraSDCardExists = 'Aircraft Camera SD Card Exists',\n  AircraftCameraSDCardRemainingPercent = 'Aircraft Camera SD Card Remaining (%)',\n  AircraftCameraSDCardStateLastUpdated = 'Aircraft Camera SD Card State Last Updated (ms)',\n  AircraftCameraChangeableLensSupported = 'Aircraft Camera Changeable Lens Supported',\n  AircraftCameraLensInstalled = 'Aircraft Camera Lens Installed',\n  AircraftCameraLensType = 'Aircraft Camera Lens Type',\n  AircraftCameraLensAFEnabled = 'Aircraft Camera Lens AF Enabled',\n  AircraftCameraLensFocusMode = 'Aircraft Camera Lens Focus Mode',\n  AircraftCameraLensFocusModeValue = 'Aircraft Camera Lens Focus Mode Value',\n  AircraftCameraLensFocusStatus = 'Aircraft Camera Lens Focus Status',\n  AircraftCameraLensFocusStatusValue = 'Aircraft Camera Lens Focus Status Value',\n  AircraftCameraLensMFAssistant = 'Aircraft Camera Lens MF Assistant',\n  AircraftCameraLensAFAssistant = 'Aircraft Camera Lens AF Assistant',\n  AircraftCameraLensAssistantWorking = 'Aircraft Camera Lens Assistant Working',\n  AircraftCameraLensStateLastUpdated = 'Aircraft Camera Lens State Last Updated (ms)',\n  CompassIndex = \"Compass Index\",\n  CompassSensorValue = \"Compass Sensor Value\",\n  CompassState = \"Compass State\",\n  CompassStateLastUpdated = \"Compass State Last Updated (ms)\",\n  CompassCalibrationState = \"Compass Calibration State\",\n  CompassCalibrationLastUpdated = \"Compass Calibration Last Updated (ms)\",\n  DeviceToAircraftDistance = 'Device > Aircraft Distance - XY (ft)',\n}\n\nexport type FlightLogRow = {\n  [prop in FlightLogHeader]: any // because csv\n};\n\nexport type FlightLogMetaData = {\n  appVersion: string;\n  session: {\n    id: string;\n    start: Date;\n    end: Date | null;\n    elapsed: number;\n  };\n  device: {\n    model: string;\n    os: string;\n    platform: string;\n  };\n  aircraft: {\n    model: string;\n    name: string;\n    firmware: string;\n  };\n  battery: {\n    chargeVolume: number;\n    remainingLifePercent: number;\n    discharges: number;\n    cells: number;\n    firmware: string;\n    serialNumber: string;\n  };\n  flightController: {\n    serialNumber: string;\n    firmware: string;\n  };\n  gimbal: {\n    firmware: string;\n  };\n  remoteController: {\n    serialNumber: string;\n    firmware: string;\n  };\n  camera: {\n    serialNumber: string;\n  };\n  user: {\n    userId: string;\n    organizationId: string;\n  };\n};\n\nexport type FlightLog = {\n  metaData: FlightLogMetaData;\n  rows: FlightLogRow[];\n  infos: any[];\n};\n\nexport type FlightLogEvent = {\n  meta: FlightLogMetaData;\n  rowIndex?: number;\n  row?: FlightLogRow;\n  info?: undefined|Array<object>;  // Empty string => undefined, else parsed JSON blob.\n};\n\n// based off of types in ios/android SDK FlightMode enums\nexport const FLIGHT_MODE_MAPPING_V4 = {\n  0: 'Manual',\n  1: 'Attitude',\n  2: 'Attitude Course Lock',\n  3: 'Attitude Hover',\n  4: 'Hover',\n  5: 'GPS Brake',\n  6: 'GPS Attitude',\n  7: 'GPS Course Lock',\n  8: 'GPS Home',\n  9: 'GPS Hotpoint',\n  10: 'Assisted Takeoff',\n  11: 'Auto Takeoff',\n  12: 'Auto Landing',\n  13: 'Attitude Landing',\n  14: 'GPS Waypoint',\n  15: 'Go Home',\n  16: 'Click Go',\n  17: 'Joystick',\n  18: 'Attitude Limited',\n  19: 'Cinematic',\n  23: 'Attitude Limited',\n  24: 'Draw',\n  25: 'GPS Follow Me',\n  26: 'ActiveTrack',\n  27: 'TapFly',\n  28: 'Pano',\n  29: 'Farming',\n  30: 'FPV',\n  31: 'GPS Sport',\n  32: 'GPS Novice',\n  33: 'Confirm Landing',\n  35: 'Terrain Follow',\n  36: 'Palm Control',\n  37: 'Quick Shot',\n  38: 'Tripod',\n  39: 'ActiveTrack Spotlight',\n  41: 'Motors Just Started',\n  43: 'GPS Gentle',\n  255: 'Unknown',\n};\n\nexport const FLIGHT_MODE_MAPPING_V5 = {\n  0: 'Manual',\n  1: 'Attitude',\n  2: 'GPS Normal',\n  3: 'POI',\n  4: 'Takeoff Ready',\n  5: 'Auto Takeoff',\n  6: 'Auto Landing',\n  7: 'Waypoint',\n  8: 'Go Home',\n  9: 'Virtual Stick',\n  10: 'Smart Flight',\n  11: 'Pano',\n  12: 'GPS Sport',\n  13: 'GPS Tripod',\n  14: 'Auto Avoidance',\n  15: 'Smart Fly',\n  16: 'Force Landing',\n  17: 'Attitude Landing',\n  18: 'Click Go',\n  19: 'Cinematic',\n  20: 'Draw',\n  21: 'GPS Follow Me',\n  22: 'GPS Novice',\n  23: 'Quick Movie',\n  24: 'Tap Fly',\n  25: 'Master Shot',\n  26: 'APAS',\n  27: 'Timelapse',\n  28: 'Motors Start',\n  29: 'Unknown',\n};\n","\n/*\nCSV Parse\n\nPlease look at the [project documentation](https://csv.js.org/parse/) for additional\ninformation.\n*/\n\nconst { Transform } = require('stream')\nconst ResizeableBuffer = require('./ResizeableBuffer')\n\nconst cr = 13\nconst nl = 10\nconst space = 32\nconst tab = 9\nconst bom_utf8 = Buffer.from([239, 187, 191])\n\nclass Parser extends Transform {\n  constructor(opts = {}){\n    super({...{readableObjectMode: true}, ...opts})\n    const options = {}\n    // Merge with user options\n    for(let opt in opts){\n      options[underscore(opt)] = opts[opt]\n    }\n    // Normalize option `bom`\n    if(options.bom === undefined || options.bom === null || options.bom === false){\n      options.bom = false\n    }else if(options.bom !== true){\n      throw new Error(`Invalid Option: bom must be true, got ${JSON.stringify(options.bom)}`)\n    }\n    // Normalize option `cast`\n    let fnCastField = null\n    if(options.cast === undefined || options.cast === null || options.cast === false || options.cast === ''){\n      options.cast = undefined\n    }else if(typeof options.cast === 'function'){\n      fnCastField = options.cast\n      options.cast = true\n    }else if(options.cast !== true){\n      throw new Error('Invalid Option: cast must be true or a function')\n    }\n    // Normalize option `cast_date`\n    if(options.cast_date === undefined || options.cast_date === null || options.cast_date === false || options.cast_date === ''){\n      options.cast_date = false\n    }else if(options.cast_date === true){\n      options.cast_date = function(value){\n        const date = Date.parse(value)\n        return !isNaN(date) ? new Date(date) : value\n      }\n    }else if(typeof options.cast_date !== 'function'){\n      throw new Error('Invalid Option: cast_date must be true or a function')\n    }\n    // Normalize option `columns`\n    let fnFirstLineToHeaders = null\n    if(options.columns === true){\n      // Fields in the first line are converted as-is to columns\n      fnFirstLineToHeaders = undefined\n    }else if(typeof options.columns === 'function'){\n      fnFirstLineToHeaders = options.columns\n      options.columns = true\n    }else if(Array.isArray(options.columns)){\n      options.columns = normalizeColumnsArray(options.columns)\n    }else if(options.columns === undefined || options.columns === null || options.columns === false){\n      options.columns = false\n    }else{\n      throw new Error(`Invalid Option columns: expect an object or true, got ${JSON.stringify(options.columns)}`)\n    }\n    // Normalize option `comment`\n    if(options.comment === undefined || options.comment === null || options.comment === false || options.comment === ''){\n      options.comment = null\n    }else{\n      if(typeof options.comment === 'string'){\n        options.comment = Buffer.from(options.comment)\n      }\n      if(!Buffer.isBuffer(options.comment)){\n        throw new Error(`Invalid Option: comment must be a buffer or a string, got ${JSON.stringify(options.comment)}`)\n      }\n    }\n    // Normalize option `delimiter`\n    if(options.delimiter === undefined || options.delimiter === null || options.delimiter === false){\n      options.delimiter = Buffer.from(',')\n    }else if(Buffer.isBuffer(options.delimiter)){\n      if(options.delimiter.length === 0){\n        throw new Error(`Invalid Option: delimiter must be a non empty buffer`)\n      }\n      // Great, nothing to do\n    }else if(typeof options.delimiter === 'string'){\n      if(options.delimiter.length === 0){\n        throw new Error(`Invalid Option: delimiter must be a non empty string`)\n      }\n      options.delimiter = Buffer.from(options.delimiter)\n    }else{\n      throw new Error(`Invalid Option: delimiter must be a string or a buffer, got ${options.delimiter}`)\n    }\n    // Normalize option `escape`\n    if(options.escape === undefined || options.escape === null){\n      options.escape = Buffer.from('\"')\n    }else if(typeof options.escape === 'string'){\n      options.escape = Buffer.from(options.escape)\n    }\n    if(!Buffer.isBuffer(options.escape)){\n      throw new Error(`Invalid Option: escape must be a buffer or a string, got ${JSON.stringify(options.escape)}`)\n    }else if(options.escape.length !== 1){\n      throw new Error(`Invalid Option Length: escape must be one character, got ${options.escape.length}`)\n    }else{\n      options.escape = options.escape[0]\n    }\n    // Normalize option `from`\n    if(options.from === undefined || options.from === null){\n      options.from = 1\n    }else{\n      if(typeof options.from === 'string' && /\\d+/.test(options.from)){\n        options.from = parseInt(options.from)\n      }\n      if(Number.isInteger(options.from)){\n        if(options.from < 0){\n          throw new Error(`Invalid Option: from must be a positive integer, got ${JSON.stringify(opts.from)}`)\n        }\n      }else{\n        throw new Error(`Invalid Option: from must be an integer, got ${JSON.stringify(options.from)}`)\n      }\n    }\n    // Normalize option `from_line`\n    if(options.from_line === undefined || options.from_line === null){\n      options.from_line = 1\n    }else{\n      if(typeof options.from_line === 'string' && /\\d+/.test(options.from_line)){\n        options.from_line = parseInt(options.from_line)\n      }\n      if(Number.isInteger(options.from_line)){\n        if(options.from_line <= 0){\n          throw new Error(`Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(opts.from_line)}`)\n        }\n      }else{\n        throw new Error(`Invalid Option: from_line must be an integer, got ${JSON.stringify(opts.from_line)}`)\n      }\n    }\n    // Normalize option `info`\n    if(options.info === undefined || options.info === null || options.info === false){\n      options.info = false\n    }else if(options.info !== true){\n      throw new Error(`Invalid Option: info must be true, got ${JSON.stringify(options.info)}`)\n    }\n    // Normalize option `max_record_size`\n    if(options.max_record_size === undefined || options.max_record_size === null || options.max_record_size === false){\n      options.max_record_size = 0\n    }else if(Number.isInteger(options.max_record_size) && options.max_record_size >= 0){\n      // Great, nothing to do\n    }else if(typeof options.max_record_size === 'string' && /\\d+/.test(options.max_record_size)){\n      options.max_record_size = parseInt(options.max_record_size)\n    }else{\n      throw new Error(`Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(options.max_record_size)}`)\n    }\n    // Normalize option `objname`\n    if(options.objname === undefined || options.objname === null || options.objname === false){\n      options.objname = undefined\n    }else if(Buffer.isBuffer(options.objname)){\n      if(options.objname.length === 0){\n        throw new Error(`Invalid Option: objname must be a non empty buffer`)\n      }\n      options.objname = options.objname.toString()\n    }else if(typeof options.objname === 'string'){\n      if(options.objname.length === 0){\n        throw new Error(`Invalid Option: objname must be a non empty string`)\n      }\n      // Great, nothing to do\n    }else{\n      throw new Error(`Invalid Option: objname must be a string or a buffer, got ${options.objname}`)\n    }\n    // Normalize option `quote`\n    if(options.quote === null || options.quote === false || options.quote === ''){\n      options.quote = null\n    }else{\n      if(options.quote === undefined || options.quote === true){\n        options.quote = Buffer.from('\"')\n      }else if(typeof options.quote === 'string'){\n        options.quote = Buffer.from(options.quote)\n      }\n      if(!Buffer.isBuffer(options.quote)){\n        throw new Error(`Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(options.quote)}`)\n      }else if(options.quote.length !== 1){\n        throw new Error(`Invalid Option Length: quote must be one character, got ${options.quote.length}`)\n      }else{\n        options.quote = options.quote[0]\n      }\n    }\n    // Normalize option `raw`\n    if(options.raw === undefined || options.raw === null || options.raw === false){\n      options.raw = false\n    }else if(options.raw !== true){\n      throw new Error(`Invalid Option: raw must be true, got ${JSON.stringify(options.raw)}`)\n    }\n    // Normalize option `record_delimiter`\n    if(!options.record_delimiter){\n      options.record_delimiter = []\n    }else if(!Array.isArray(options.record_delimiter)){\n      options.record_delimiter = [options.record_delimiter]\n    }\n    options.record_delimiter = options.record_delimiter.map( function(rd){\n      if(typeof rd === 'string'){\n        rd = Buffer.from(rd)\n      }\n      return rd\n    })\n    // Normalize option `relax`\n    if(typeof options.relax === 'boolean'){\n      // Great, nothing to do\n    }else if(options.relax === undefined || options.relax === null){\n      options.relax = false\n    }else{\n      throw new Error(`Invalid Option: relax must be a boolean, got ${JSON.stringify(options.relax)}`)\n    }\n    // Normalize option `relax_column_count`\n    if(typeof options.relax_column_count === 'boolean'){\n      // Great, nothing to do\n    }else if(options.relax_column_count === undefined || options.relax_column_count === null){\n      options.relax_column_count = false\n    }else{\n      throw new Error(`Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(options.relax_column_count)}`)\n    }\n    // Normalize option `skip_empty_lines`\n    if(typeof options.skip_empty_lines === 'boolean'){\n      // Great, nothing to do\n    }else if(options.skip_empty_lines === undefined || options.skip_empty_lines === null){\n      options.skip_empty_lines = false\n    }else{\n      throw new Error(`Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(options.skip_empty_lines)}`)\n    }\n    // Normalize option `skip_lines_with_empty_values`\n    if(typeof options.skip_lines_with_empty_values === 'boolean'){\n      // Great, nothing to do\n    }else if(options.skip_lines_with_empty_values === undefined || options.skip_lines_with_empty_values === null){\n      options.skip_lines_with_empty_values = false\n    }else{\n      throw new Error(`Invalid Option: skip_lines_with_empty_values must be a boolean, got ${JSON.stringify(options.skip_lines_with_empty_values)}`)\n    }\n    // Normalize option `skip_lines_with_error`\n    if(typeof options.skip_lines_with_error === 'boolean'){\n      // Great, nothing to do\n    }else if(options.skip_lines_with_error === undefined || options.skip_lines_with_error === null){\n      options.skip_lines_with_error = false\n    }else{\n      throw new Error(`Invalid Option: skip_lines_with_error must be a boolean, got ${JSON.stringify(options.skip_lines_with_error)}`)\n    }\n    // Normalize option `rtrim`\n    if(options.rtrim === undefined || options.rtrim === null || options.rtrim === false){\n      options.rtrim = false\n    }else if(options.rtrim !== true){\n      throw new Error(`Invalid Option: rtrim must be a boolean, got ${JSON.stringify(options.rtrim)}`)\n    }\n    // Normalize option `ltrim`\n    if(options.ltrim === undefined || options.ltrim === null || options.ltrim === false){\n      options.ltrim = false\n    }else if(options.ltrim !== true){\n      throw new Error(`Invalid Option: ltrim must be a boolean, got ${JSON.stringify(options.ltrim)}`)\n    }\n    // Normalize option `trim`\n    if(options.trim === undefined || options.trim === null || options.trim === false){\n      options.trim = false\n    }else if(options.trim !== true){\n      throw new Error(`Invalid Option: trim must be a boolean, got ${JSON.stringify(options.trim)}`)\n    }\n    // Normalize options `trim`, `ltrim` and `rtrim`\n    if(options.trim === true && opts.ltrim !== false){\n      options.ltrim = true\n    }else if(options.ltrim !== true){\n      options.ltrim = false\n    }\n    if(options.trim === true && opts.rtrim !== false){\n      options.rtrim = true\n    }else if(options.rtrim !== true){\n      options.rtrim = false\n    }\n    // Normalize option `to`\n    if(options.to === undefined || options.to === null){\n      options.to = -1\n    }else{\n      if(typeof options.to === 'string' && /\\d+/.test(options.to)){\n        options.to = parseInt(options.to)\n      }\n      if(Number.isInteger(options.to)){\n        if(options.to <= 0){\n          throw new Error(`Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(opts.to)}`)\n        }\n      }else{\n        throw new Error(`Invalid Option: to must be an integer, got ${JSON.stringify(opts.to)}`)\n      }\n    }\n    // Normalize option `to_line`\n    if(options.to_line === undefined || options.to_line === null){\n      options.to_line = -1\n    }else{\n      if(typeof options.to_line === 'string' && /\\d+/.test(options.to_line)){\n        options.to_line = parseInt(options.to_line)\n      }\n      if(Number.isInteger(options.to_line)){\n        if(options.to_line <= 0){\n          throw new Error(`Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(opts.to_line)}`)\n        }\n      }else{\n        throw new Error(`Invalid Option: to_line must be an integer, got ${JSON.stringify(opts.to_line)}`)\n      }\n    }\n    this.info = {\n      comment_lines: 0,\n      empty_lines: 0,\n      invalid_field_length: 0,\n      lines: 1,\n      records: 0\n    }\n    this.options = options\n    this.state = {\n      bomSkipped: false,\n      castField: fnCastField,\n      commenting: false,\n      enabled: options.from_line === 1,\n      escaping: false,\n      escapeIsQuote: options.escape === options.quote,\n      expectedRecordLength: options.columns === null ? 0 : options.columns.length,\n      field: new ResizeableBuffer(20),\n      firstLineToHeaders: fnFirstLineToHeaders,\n      info: Object.assign({}, this.info),\n      previousBuf: undefined,\n      quoting: false,\n      stop: false,\n      rawBuffer: new ResizeableBuffer(100),\n      record: [],\n      recordHasError: false,\n      record_length: 0,\n      recordDelimiterMaxLength: options.record_delimiter.length === 0 ? 2 : Math.max(...options.record_delimiter.map( (v) => v.length)),\n      trimChars: [Buffer.from(' ')[0], Buffer.from('\\t')[0]],\n      wasQuoting: false,\n      wasRowDelimiter: false\n    }\n  }\n  // Implementation of `Transform._transform`\n  _transform(buf, encoding, callback){\n    if(this.state.stop === true){\n      return\n    }\n    const err = this.__parse(buf, false)\n    if(err !== undefined){\n      this.state.stop = true\n    }\n    callback(err)\n  }\n  // Implementation of `Transform._flush`\n  _flush(callback){\n    if(this.state.stop === true){\n      return\n    }\n    const err = this.__parse(undefined, true)\n    callback(err)\n  }\n  // Central parser implementation\n  __parse(nextBuf, end){\n    const {bom, comment, escape, from, from_line, info, ltrim, max_record_size, quote, raw, relax, rtrim, skip_empty_lines, to, to_line} = this.options\n    let {record_delimiter} = this.options\n    const {bomSkipped, previousBuf, rawBuffer, escapeIsQuote, trimChars} = this.state\n    let buf\n    if(previousBuf === undefined){\n      if(nextBuf === undefined){\n        // Handle empty string\n        this.push(null)\n        return\n      }else{\n        buf = nextBuf\n      }\n    }else if(previousBuf !== undefined && nextBuf === undefined){\n      buf = previousBuf\n    }else{\n      buf = Buffer.concat([previousBuf, nextBuf])\n    }\n    // Handle UTF BOM\n    if(bomSkipped === false){\n      if(bom === false){\n        this.state.bomSkipped = true\n      }else if(buf.length < 3){\n        // No enough data\n        if(end === false){\n          // Wait for more data\n          this.state.previousBuf = buf\n          return\n        }\n        // skip BOM detect because data length < 3\n      }else{\n        if(bom_utf8.compare(buf, 0, 3) === 0){\n          // Skip BOM\n          buf = buf.slice(3)\n        }\n        this.state.bomSkipped = true\n      }\n    }\n    const bufLen = buf.length\n    let pos\n    for(pos = 0; pos < bufLen; pos++){\n      // Ensure we get enough space to look ahead\n      // There should be a way to move this out of the loop\n      if(this.__needMoreData(pos, bufLen, end)){\n        break\n      }\n      if(this.state.wasRowDelimiter === true){\n        this.info.lines++\n        if(info === true && this.state.record.length === 0 && this.state.field.length === 0 && this.state.wasQuoting === false){\n          this.state.info = Object.assign({}, this.info)\n        }\n        this.state.wasRowDelimiter = false\n      }\n      if(to_line !== -1 && this.info.lines > to_line){\n        this.state.stop = true\n        this.push(null)\n        return\n      }\n      // Auto discovery of record_delimiter, unix, mac and windows supported\n      if(this.state.quoting === false && record_delimiter.length === 0){\n        const record_delimiterCount = this.__autoDiscoverRowDelimiter(buf, pos)\n        if(record_delimiterCount){\n          record_delimiter = this.options.record_delimiter\n        }\n      }\n      const chr = buf[pos]\n      if(raw === true){\n        rawBuffer.append(chr)\n      }\n      if((chr === cr || chr === nl) && this.state.wasRowDelimiter === false ){\n        this.state.wasRowDelimiter = true\n      }\n      // Previous char was a valid escape char\n      // treat the current char as a regular char\n      if(this.state.escaping === true){\n        this.state.escaping = false\n      }else{\n        // Escape is only active inside quoted fields\n        if(this.state.quoting === true && chr === escape && pos + 1 < bufLen){\n          // We are quoting, the char is an escape chr and there is a chr to escape\n          if(escapeIsQuote){\n            if(buf[pos+1] === quote){\n              this.state.escaping = true\n              continue\n            }\n          }else{\n            this.state.escaping = true\n            continue\n          }\n        }\n        // Not currently escaping and chr is a quote\n        // TODO: need to compare bytes instead of single char\n        if(this.state.commenting === false && chr === quote){\n          if(this.state.quoting === true){\n            const nextChr = buf[pos+1]\n            const isNextChrTrimable = rtrim && this.__isCharTrimable(nextChr)\n            // const isNextChrComment = nextChr === comment\n            const isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos+1, nextChr)\n            const isNextChrDelimiter = this.__isDelimiter(nextChr, buf, pos+1)\n            const isNextChrRowDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRowDelimiter(buf, pos+1) : this.__isRecordDelimiter(nextChr, buf, pos+1)\n            // Escape a quote\n            // Treat next char as a regular character\n            // TODO: need to compare bytes instead of single char\n            if(chr === escape && nextChr === quote){\n              pos++\n            }else if(!nextChr || isNextChrDelimiter || isNextChrRowDelimiter || isNextChrComment || isNextChrTrimable){\n              this.state.quoting = false\n              this.state.wasQuoting = true\n              continue\n            }else if(relax === false){\n              const err = this.__error(`Invalid Closing Quote: got \"${String.fromCharCode(nextChr)}\" at line ${this.info.lines} instead of delimiter, row delimiter, trimable character (if activated) or comment`)\n              if(err !== undefined) return err\n            }else{\n              this.state.quoting = false\n              this.state.wasQuoting = true\n              // continue\n              this.state.field.prepend(quote)\n            }\n          }else{\n            if(this.state.field.length !== 0){\n              // In relax mode, treat opening quote preceded by chrs as regular\n              if( relax === false ){\n                const err = this.__error(`Invalid opening quote at line ${this.info.lines}`)\n                if(err !== undefined) return err\n              }\n            }else{\n              this.state.quoting = true\n              continue\n            }\n          }\n        }\n        if(this.state.quoting === false){\n          let recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos)\n          if(recordDelimiterLength !== 0){\n            // Do not emit comments which take a full line\n            const skipCommentLine = this.state.commenting && (this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0)\n            if(skipCommentLine){\n              this.info.comment_lines++\n              // Skip full comment line\n            }else{\n              // Skip if line is empty and skip_empty_lines activated\n              if(skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0){\n                this.info.empty_lines++\n                pos += recordDelimiterLength - 1\n                continue\n              }\n              // Activate records emition if above from_line\n              if(this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1: 0 ) >= from_line){\n                this.state.enabled = true\n                this.__resetField()\n                this.__resetRow()\n                pos += recordDelimiterLength - 1\n                continue\n              }else{\n                const errField = this.__onField()\n                if(errField !== undefined) return errField\n                const errRecord = this.__onRow()\n                if(errRecord !== undefined) return errRecord\n              }\n              if(to !== -1 && this.info.records >= to){\n                this.state.stop = true\n                this.push(null)\n                return\n              }\n            }\n            this.state.commenting = false\n            pos += recordDelimiterLength - 1\n            continue\n          }\n          if(this.state.commenting){\n            continue\n          }\n          const commentCount = comment === null ? 0 : this.__compareBytes(comment, buf, pos, chr)\n          if(commentCount !== 0){\n            this.state.commenting = true\n            continue\n          }\n          let delimiterLength = this.__isDelimiter(chr, buf, pos)\n          if(delimiterLength !== 0){\n            const errField = this.__onField()\n            if(errField !== undefined) return errField\n            pos += delimiterLength - 1\n            continue\n          }\n        }\n      }\n      if(this.state.commenting === false){\n        if(max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size){\n          const err = this.__error(`Max Record Size: record exceed the maximum number of tolerated bytes of ${max_record_size} on line ${this.info.lines}`)\n          if(err !== undefined) return err\n        }\n      }\n\n      const lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(chr)\n      // rtrim in non quoting is handle in __onField\n      const rappend = rtrim === false || this.state.wasQuoting === false\n      if( lappend === true && rappend === true ){\n        this.state.field.append(chr)\n      }else if(rtrim === true && !this.__isCharTrimable(chr)){\n        const err = this.__error(`Invalid Closing Quote: found non trimable byte after quote at line ${this.info.lines}`)\n        if(err !== undefined) return err\n      }\n    }\n    if(end === true){\n      if(this.state.quoting === true){\n        const err = this.__error(`Invalid Closing Quote: quote is not closed at line ${this.info.lines}`)\n        if(err !== undefined) return err\n      }else{\n        // Skip last line if it has no characters\n        if(this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0){\n          const errField = this.__onField()\n          if(errField !== undefined) return errField\n          const errRecord = this.__onRow()\n          if(errRecord !== undefined) return errRecord\n        }else if(this.state.wasRowDelimiter === true){\n          this.info.empty_lines++\n        }else if(this.state.commenting === true){\n          this.info.comment_lines++\n        }\n      }\n    }else{\n      this.state.previousBuf = buf.slice(pos)\n    }\n    if(this.state.wasRowDelimiter === true){\n      this.info.lines++\n      this.state.wasRowDelimiter = false\n    }\n  }\n  // Helper to test if a character is a space or a line delimiter\n  __isCharTrimable(chr){\n    return chr === space || chr === tab || chr === cr || chr === nl\n  }\n  __onRow(){\n    const {columns, info, from, relax_column_count, raw, skip_lines_with_empty_values} = this.options\n    const {enabled, record} = this.state\n    // Convert the first line into column names\n    if(columns === true){\n      return this.__firstLineToColumns(record)\n    }\n    const recordLength = record.length\n    if(columns === false && this.info.records === 0){\n      this.state.expectedRecordLength = recordLength\n    }else if(enabled === true){\n      if(recordLength !== this.state.expectedRecordLength){\n        if(relax_column_count === true){\n          this.info.invalid_field_length++\n        }else{\n          if(columns === false){\n            const err = this.__error(`Invalid Record Length: expect ${this.state.expectedRecordLength}, got ${recordLength} on line ${this.info.lines}`)\n            if(err !== undefined) return err\n          }else{\n            const err = this.__error(`Invalid Record Length: header length is ${columns.length}, got ${recordLength} on line ${this.info.lines}`)\n            if(err !== undefined) return err\n          }\n        }\n      }\n    }\n    if(enabled === false){\n      return this.__resetRow()\n    }\n    if(skip_lines_with_empty_values === true){\n      if(record.map( (field) => field.trim() ).join('') === ''){\n        this.__resetRow()\n        return\n      }\n    }\n    if(this.state.recordHasError === true){\n      this.__resetRow()\n      this.state.recordHasError = false\n      return\n    }\n    this.info.records++\n    if(from === 1 || this.info.records >= from){\n      if(columns !== false){\n        const obj = {}\n        // Transform record array to an object\n        for(let i in record){\n          if(columns[i] === undefined || columns[i].disabled) continue\n          obj[columns[i].name] = record[i]\n        }\n        const {objname} = this.options\n        if(objname === undefined){\n          if(raw === true || info === true){\n            this.push(Object.assign(\n              {record: obj},\n              (raw === true ? {raw: this.state.rawBuffer.toString()}: {}),\n              (info === true ? {info: this.state.info}: {})\n            ))\n          }else{\n            this.push(obj)\n          }\n        }else{\n          if(raw === true || info === true){\n            this.push(Object.assign(\n              {record: [obj[objname], obj]},\n              raw === true ? {raw: this.state.rawBuffer.toString()}: {},\n              info === true ? {info: this.state.info}: {}\n            ))\n          }else{\n            this.push([obj[objname], obj])\n          }\n        }\n      }else{\n        if(raw === true || info === true){\n          this.push(Object.assign(\n            {record: record},\n            raw === true ? {raw: this.state.rawBuffer.toString()}: {},\n            info === true ? {info: this.state.info}: {}\n          ))\n        }else{\n          this.push(record)\n        }\n      }\n    }\n    this.__resetRow()\n  }\n  __firstLineToColumns(record){\n    const {firstLineToHeaders} = this.state\n    try{\n      // record = record.filter(function(field){ return field !== undefined})\n      const headers = firstLineToHeaders === undefined ? record : firstLineToHeaders.call(null, record)\n      if(!Array.isArray(headers)){\n        return this.__error(`Invalid Header Mapping: expect an array, got ${JSON.stringify(headers)}`)\n      }\n      const normalizedHeaders = normalizeColumnsArray(headers)\n      this.state.expectedRecordLength = normalizedHeaders.length\n      this.options.columns = normalizedHeaders\n      this.__resetRow()\n      return\n    }catch(err){\n      return err\n    }\n  }\n  __resetRow(){\n    const {info} = this.options\n    if(this.options.raw === true){\n      this.state.rawBuffer.reset()\n    }\n    this.state.record = []\n    this.state.record_length = 0\n  }\n  __onField(){\n    const {cast, rtrim, max_record_size} = this.options\n    const {enabled, wasQuoting} = this.state\n    // Deal with from_to options\n    if(this.options.columns !== true && enabled === false){\n      return this.__resetField()\n    }\n    let field = this.state.field.toString()\n    if(rtrim === true && wasQuoting === false){\n      field = field.trimRight()\n    }\n    if(cast === true){\n      const [err, f] = this.__cast(field)\n      if(err !== undefined) return err\n      field = f\n    }\n    this.state.record.push(field)\n    // Increment record length if record size must not exceed a limit\n    if(max_record_size !== 0 && typeof field === 'string'){\n      this.state.record_length += field.length\n    }\n    this.__resetField()\n  }\n  __resetField(){\n    this.state.field.reset()\n    this.state.wasQuoting = false\n  }\n  // Return a tuple with the error and the casted value\n  __cast(field){\n    const isColumns = Array.isArray(this.options.columns)\n    // Dont loose time calling cast if the field wont be part of the final record\n    if( isColumns === true && this.options.columns.length <= this.state.record.length ){\n      return [undefined, undefined]\n    }\n    const context = {\n      column: isColumns === true ?\n        this.options.columns[this.state.record.length].name :\n        this.state.record.length,\n      empty_lines: this.info.empty_lines,\n      header: this.options.columns === true,\n      index: this.state.record.length,\n      invalid_field_length: this.info.invalid_field_length,\n      quoting: this.state.wasQuoting,\n      lines: this.info.lines,\n      records: this.info.records\n    }\n    if(this.state.castField !== null){\n      try{\n        return [undefined, this.state.castField.call(null, field, context)]\n      }catch(err){\n        return [err]\n      }\n    }\n    if(this.__isFloat(field)){\n      return [undefined, parseFloat(field)]\n    }else if(this.options.cast_date !== false){\n      return [undefined, this.options.cast_date.call(null, field, context)]\n    }\n    return [undefined, field]\n  }\n  // Keep it in case we implement the `cast_int` option\n  // __isInt(value){\n  //   // return Number.isInteger(parseInt(value))\n  //   // return !isNaN( parseInt( obj ) );\n  //   return /^(\\-|\\+)?[1-9][0-9]*$/.test(value)\n  // }\n  __isFloat(value){\n    return (value - parseFloat( value ) + 1) >= 0 // Borrowed from jquery\n  }\n  __compareBytes(sourceBuf, targetBuf, pos, firtByte){\n    if(sourceBuf[0] !== firtByte) return 0\n    const sourceLength = sourceBuf.length\n    for(let i = 1; i < sourceLength; i++){\n      if(sourceBuf[i] !== targetBuf[pos+i]) return 0\n    }\n    return sourceLength\n  }\n  __needMoreData(i, bufLen, end){\n    if(end){\n      return false\n    }\n    const {comment, delimiter, escape} = this.options\n    const {quoting, recordDelimiterMaxLength} = this.state\n    const numOfCharLeft = bufLen - i - 1\n    const requiredLength = Math.max(\n      // Skip if the remaining buffer smaller than comment\n      comment ? comment.length : 0,\n      // Skip if the remaining buffer smaller than row delimiter\n      recordDelimiterMaxLength,\n      // Skip if the remaining buffer can be row delimiter following the closing quote\n      // 1 is for quote.length\n      quoting ? (1 + recordDelimiterMaxLength) : 0,\n      // Skip if the remaining buffer can be delimiter\n      delimiter.length,\n      // Skip if the remaining buffer can be escape sequence\n      // 1 is for escape.length\n      1\n    )\n    return numOfCharLeft < requiredLength\n  }\n  __isDelimiter(chr, buf, pos){\n    const {delimiter} = this.options\n    const delLength = delimiter.length\n    if(delimiter[0] !== chr) return 0\n    for(let i = 1; i < delLength; i++){\n      if(delimiter[i] !== buf[pos+i]) return 0\n    }\n    return delimiter.length\n  }\n  __isRecordDelimiter(chr, buf, pos){\n    const {record_delimiter} = this.options\n    const recordDelimiterLength = record_delimiter.length\n    loop1: for(let i = 0; i < recordDelimiterLength; i++){\n      const rd = record_delimiter[i]\n      const rdLength = rd.length\n      if(rd[0] !== chr){\n        continue\n      }\n      for(let j = 1; j < rdLength; j++){\n        if(rd[j] !== buf[pos+j]){\n          continue loop1\n        }\n      }\n      return rd.length\n    }\n    return 0\n  }\n  __autoDiscoverRowDelimiter(buf, pos){\n    const chr = buf[pos]\n    if(chr === cr){\n      if(buf[pos+1] === nl){\n        this.options.record_delimiter.push(Buffer.from('\\r\\n'))\n        this.state.recordDelimiterMaxLength = 2\n        return 2\n      }else{\n        this.options.record_delimiter.push(Buffer.from('\\r'))\n        this.state.recordDelimiterMaxLength = 1\n        return 1\n      }\n    }else if(chr === nl){\n      this.options.record_delimiter.push(Buffer.from('\\n'))\n      this.state.recordDelimiterMaxLength = 1\n      return 1\n    }\n    return 0\n  }\n  __error(msg){\n    const {skip_lines_with_error} = this.options\n    const err = new Error(msg)\n    if(skip_lines_with_error){\n      this.state.recordHasError = true\n      this.emit('skip', err)\n      return undefined\n    }else{\n      return err\n    }\n  }\n}\n\nconst parse = function(){\n  let data, options, callback\n  for(let i in arguments){\n    const argument = arguments[i]\n    const type = typeof argument\n    if(data === undefined && (typeof argument === 'string' || Buffer.isBuffer(argument))){\n      data = argument\n    }else if(options === undefined && isObject(argument)){\n      options = argument\n    }else if(callback === undefined && type === 'function'){\n      callback = argument\n    }else{\n      throw new Error(`Invalid argument: got ${JSON.stringify(argument)} at index ${i}`)\n    }\n  }\n  const parser = new Parser(options)\n  if(callback){\n    const records = options === undefined || options.objname === undefined ? [] : {}\n    parser.on('readable', function(){\n      let record\n      while(record = this.read()){\n        if(options === undefined || options.objname === undefined){\n          records.push(record)\n        }else{\n          records[record[0]] = record[1]\n        }\n      }\n    })\n    parser.on('error', function(err){\n      callback(err, undefined, parser.info)\n    })\n    parser.on('end', function(){\n      callback(undefined, records, parser.info)\n    })\n  }\n  if(data !== undefined){\n    parser.write(data)\n    parser.end()\n  }\n  return parser\n}\n\nparse.Parser = Parser\n\nmodule.exports = parse\n\nconst underscore = function(str){\n  return str.replace(/([A-Z])/g, function(_, match, index){\n    return '_' + match.toLowerCase()\n  })\n}\n\nconst isObject = function(obj){\n  return (typeof obj === 'object' && obj !== null && !Array.isArray(obj))\n}\n\nconst normalizeColumnsArray = function(columns){\n  // console.log('columns', columns)\n  const normalizedColumns = [];\n\n  for(let i=0; i< columns.length; i++){\n    const column = columns[i]\n    if(column === undefined || column === null || column === false){\n      normalizedColumns[i] = { disabled: true }\n    }else if(typeof column === 'string'){\n      normalizedColumns[i] = { name: column }\n    }else if(isObject(column)){\n      if(typeof column.name !== 'string'){\n        throw new Error(`Invalid Option columns: property \"name\" is required at position ${i} when column is an object literal`)\n      }\n      normalizedColumns[i] = column\n    }else{\n      throw new Error(`Invalid Option columns: expect a string or an object, got ${JSON.stringify(column)} at position ${i}`)\n    }\n  }\n  // console.log(normalizedColumns)\n  return normalizedColumns;\n}\n","import { FlightLogHeader } from './types';\n\nexport const INT_FIELDS = new Set([\n  FlightLogHeader.AircraftBatteryCell1Voltage,\n  FlightLogHeader.AircraftBatteryCell2Voltage,\n  FlightLogHeader.AircraftBatteryCell3Voltage,\n  FlightLogHeader.AircraftBatteryCell4Voltage,\n  FlightLogHeader.AircraftBatteryCharge,\n  FlightLogHeader.AircraftBatteryCurrent,\n  FlightLogHeader.AircraftBatteryTemperature,\n  FlightLogHeader.AircraftBatteryVoltage,\n  FlightLogHeader.AircraftCameraLensFocusModeValue,\n  FlightLogHeader.AircraftCameraLensFocusStatusValue,\n  FlightLogHeader.AircraftCameraModeValue,\n  FlightLogHeader.AircraftFlightModeValue,\n  FlightLogHeader.AircraftGPSSignalValue,\n  FlightLogHeader.AircraftNoFlyValue,\n  FlightLogHeader.AircraftSatellites,\n  FlightLogHeader.GimbalModeValue,\n  FlightLogHeader.AircraftSmartGoHomeRadius,\n  FlightLogHeader.AircraftSmartGoHomeCountdown,\n  FlightLogHeader.AircraftVelocityX,\n  FlightLogHeader.AircraftVelocityY,\n  FlightLogHeader.AircraftVelocityZ,\n  FlightLogHeader.RCHorizontalAccuaracy,\n  FlightLogHeader.RCLatitude,\n  FlightLogHeader.RCLongitude,\n  FlightLogHeader.LandingGearStatusValue,\n  FlightLogHeader.LandingGearModeValue,\n  FlightLogHeader.RCStateValue,\n  FlightLogHeader.RCLandingGearValue,\n]);\n\nexport const FLOAT_FIELDS = new Set([\n  FlightLogHeader.AircraftBarometricAltitude,\n  FlightLogHeader.AircraftBatteryPowerPercent,\n  FlightLogHeader.AircraftCameraSDCardRemainingPercent,\n  FlightLogHeader.AircraftHeading,\n  FlightLogHeader.AircraftLatitude,\n  FlightLogHeader.AircraftLongitude,\n  FlightLogHeader.AircraftNoFlyLatitude,\n  FlightLogHeader.AircraftNoFlyLongitude,\n  FlightLogHeader.AircraftNoFlyRadius,\n  FlightLogHeader.AircraftPitch,\n  FlightLogHeader.AircraftRoll,\n  FlightLogHeader.AircraftSmartGoHomeFlightReturnTime,\n  FlightLogHeader.AircraftSmartGoHomeFlightTimeRemaining,\n  FlightLogHeader.AircraftSmartGoHomeLandingPower,\n  FlightLogHeader.AircraftSmartGoHomeLandingTime,\n  FlightLogHeader.AircraftSmartGoHomeReturnPower,\n  FlightLogHeader.AircraftSpeed,\n  FlightLogHeader.AircraftUltrasonicAltitude,\n  FlightLogHeader.DeviceToAircraftDistance,\n  FlightLogHeader.ElapsedTime,\n  FlightLogHeader.GimbalPitch,\n  FlightLogHeader.GimbalPitchAtStop,\n  FlightLogHeader.GimbalRoll,\n  FlightLogHeader.GimbalRollAtStop,\n  FlightLogHeader.GimbalYaw,\n  FlightLogHeader.GimbalYawAtStop,\n  FlightLogHeader.HomeLatitude,\n  FlightLogHeader.HomeLongitude,\n  FlightLogHeader.RCBatteryPercentRemaining,\n  FlightLogHeader.RCLeftHorizontal,\n  FlightLogHeader.RCRightHorizontal,\n  FlightLogHeader.RCLeftVertical,\n  FlightLogHeader.RCRightVertical,\n]);\n\nexport const BOOL_FIELDS = new Set([\n  FlightLogHeader.AircraftCameraBurstCapture,\n  FlightLogHeader.AircraftCameraIntervalCapture,\n  FlightLogHeader.AircraftCameraLensAFAssistant,\n  FlightLogHeader.AircraftCameraLensAFEnabled,\n  FlightLogHeader.AircraftCameraLensAssistantWorking,\n  FlightLogHeader.AircraftCameraOverheated,\n  FlightLogHeader.AircraftCameraRawCapture,\n  FlightLogHeader.AircraftCameraBurstCapture,\n  FlightLogHeader.AircraftCameraRecording,\n  FlightLogHeader.AircraftCameraSDCardExists,\n  FlightLogHeader.AircraftCameraSensorError,\n  FlightLogHeader.AircraftCameraSingleCapture,\n  FlightLogHeader.AircraftCameraStoringPhoto,\n  FlightLogHeader.AircraftFlying,\n  FlightLogHeader.AircraftIMUPreheating,\n  FlightLogHeader.AircraftMotorsOn,\n  FlightLogHeader.AircraftSmartGoHomeRequesting,\n  FlightLogHeader.AircraftUltrasonicOn,\n  FlightLogHeader.AircraftVisionOn,\n  FlightLogHeader.LandingGearIsMovable,\n  FlightLogHeader.RCGoHome,\n  FlightLogHeader.RCRecord,\n  FlightLogHeader.RCShutter,\n  FlightLogHeader.RCPlayback,\n  FlightLogHeader.RCPause,\n  FlightLogHeader.RCCustom1,\n  FlightLogHeader.RCCustom2,\n  FlightLogHeader.RCSattelites,\n  FlightLogHeader.RCGSPDataIsValid,\n  FlightLogHeader.RCLeftHorizontal,\n  FlightLogHeader.RCRightHorizontal,\n  FlightLogHeader.RCLeftVertical,\n  FlightLogHeader.RCRightVertical,\n  FlightLogHeader.AircraftCameraChangeableLensSupported,\n  FlightLogHeader.AircraftCameraLensInstalled,\n  FlightLogHeader.AircraftCameraLensMFAssistant,\n]);\n\nexport const DATE_FIELDS = new Set([\n    FlightLogHeader.DateTime,\n]);\n","import parse from 'csv-parse';\n\nimport { FlightLogRow, FlightLogHeader, FlightLogMetaData, FlightLog, FlightLogEvent } from './types';\nimport { INT_FIELDS, BOOL_FIELDS, FLOAT_FIELDS, DATE_FIELDS } from './field-types';\n\nconst syncParse = require('csv-parse/lib/sync');\n\n\nconst META_REGEX = {\n  appVersion: /^#DroneDeploy\\s+(.+)$/,\n  sessionId: /^Session ID\\s+(.+)$/,\n  sessionStart: /^Session Start\\s+(.+)$/,\n  sessionEnd: /^Date\\/Time \\(UTC\\)\\s+(.+)$/,\n  deviceModel: /^Device Model\\s+(.+)$/,\n  deviceOS: /^Device Operating System\\s+(.+)$/,\n  aircraftModel: /^Aircraft Model\\s+(.+)$/,\n  aircraftName: /^Aircraft Name\\s+(.+)$/,\n  aircraftFirmware: /^Aircraft Firmware\\s+(.+)$/,\n  batteryChargeVolume: /^Full Charge Volume \\(mAh\\)\\s+(.+)$/,\n  batteryRemainingLife: /^Remaining Life \\(%\\)\\s+(.+)$/,\n  batteryDischarges: /^Discharges\\s+(.+)$/,\n  batteryCells: /^Battery Cells Number\\s+(.+)$/,\n  batterySerialNumber: /^Battery Serial Number\\s+(.+)$/,\n  batteryFirmware: /^Battery Firmware\\s+(.+)$/,\n  fcSerialNumber: /^Flight Controller Serial Number\\s+(.+)$/,\n  fcFirmware: /^Flight Controller Firmware\\s+(.+)$/,\n  footerLines: /^#Flight Recorder Session End|^Date\\/Time \\(UTC\\)|^Elapsed Time \\(sec\\)/,\n  gimbalFirmware: /^Gimbal Firmware\\s+(.+)$/,\n  rcSerialNumber: /^Remote Control Serial Number\\s+(.+)$/,\n  rcFirmware: /^Remote Control Firmware\\s+(.+)$/,\n  cameraSerialNumber: /^Camera Serial Number\\s+(.+)$/,\n  elapsedTime: /^Elapsed Time \\(sec\\)\\s+(.+)$/,\n  userId: /^User ID\\s+(.+)$/,\n  organizationId: /^Organization ID\\s+(.+)$/,\n  platform: /^Platform\\s+(.+)$/,\n};\n\nexport type Subscriber<T> = (value: T) => void;\nexport type ErrorSubscriber = (value: any) => void;\nexport type CompletionSubscriber = () => void;\n\nexport interface QuasiObservable<T> {\n    subscribe(sub: Subscriber<T>, errSub?: ErrorSubscriber, completionSub?: CompletionSubscriber): void;\n    toPromise(): Promise<T>;\n}\n\nexport class QuasiSubject<T> implements QuasiObservable<T> {\n    private subscribers: Subscriber<T>[] = [];\n    private errorSubscribers: ErrorSubscriber[] = [];\n    private completionSubscribers: CompletionSubscriber[] = [];\n    private isFinished = false;\n\n    next(value: T) {\n        if (this.isFinished) {\n            return;\n        }\n        this.subscribers.forEach((s) => s(value));\n    }\n\n    complete() {\n        if (this.isFinished) {\n            return;\n        }\n        this.isFinished = true;\n        this.completionSubscribers.forEach((sub) => sub());\n    }\n\n    error(error: any) {\n        if (this.isFinished) {\n            return;\n        }\n        this.errorSubscribers.forEach((errSub) => errSub(error));\n        this.complete();\n    }\n\n    subscribe(sub: Subscriber<T>, errSub?: ErrorSubscriber, completionSub?: CompletionSubscriber) {\n        this.subscribers.push(sub);\n        if (errSub) {\n            this.errorSubscribers.push(errSub);\n        }\n        if (completionSub) {\n            this.completionSubscribers.push(completionSub);\n        }\n    }\n\n    toPromise(): Promise<T> {\n        const source = this;\n        return new Promise<T>(function (resolve, reject) {\n            let value: T;\n            source.subscribe(function (v) {\n                value = v;\n            }, reject, function () {\n                resolve(value);\n            });\n        });\n    }\n}\n\nexport function parseLogStream(logStream: QuasiSubject<string>): QuasiObservable<FlightLogEvent> {\n  const headerMetaLines: string[] = [];\n  let meta = {} as FlightLogMetaData;\n  let rowHeaderLine: string;\n  let row: FlightLogRow;\n\n  const progress = { index: 0, completed: false };\n  let end: any;\n  const result = new QuasiSubject<FlightLogEvent>();\n\n  logStream.subscribe((line: string) => {\n    line = line.trim();\n    if (!line.length) {\n      return;\n    }\n\n    if (!rowHeaderLine) {\n      if (line.startsWith(FlightLogHeader.DateTime.split(' ')[0])) {  // Strip off timezone.\n        rowHeaderLine = line;\n        meta = parseMetaData(headerMetaLines, []);\n        result.next({\n          meta,\n          rowIndex: progress.index\n        });\n      } else {\n        headerMetaLines.push(line);\n        progress.index++;\n      }\n      return;\n    }\n\n    if (META_REGEX.footerLines.test(line)) {\n      if (META_REGEX.sessionEnd.test(line)) {\n        end = fromUtcDateStr(findMatch([line], META_REGEX.sessionEnd));\n      } else if (META_REGEX.elapsedTime.test(line)) {\n        const elapsed = findMatch([line], META_REGEX.elapsedTime);\n\n        // This is the end of the parsing. Because normal lines are parsed through a Promise, they will be delivered\n        // asynchronously. So we must ensure that this result is also delivered asynchronously.\n        setTimeout(() => {\n          const parsedElapsed = elapsed === 'N/A' ? 0 : parseFloat(elapsed);\n          if (parsedElapsed) {\n            meta.session.elapsed = parsedElapsed;\n          }\n          if (end) {\n            meta.session.end = end;\n          }\n          result.next({\n            meta,\n            rowIndex: progress.index++,\n          });\n          result.complete();\n          progress.completed = true;\n        }, 0);\n      }\n    } else {\n      parseBody([rowHeaderLine, line], true).then((rows) => {\n        row = rows[0];\n        meta.session.end = row[FlightLogHeader.DateTime];\n        meta.session.elapsed = row[FlightLogHeader.ElapsedTime];\n        result.next({\n          meta,\n          rowIndex: progress.index++,\n          row,\n          info: parseJsonInfo(row.Info),  // Parsed Info column, if the column was populated with a JSON array.\n        })\n      });\n    }\n\n  }, (err) => { console.error('parsing error: ' + err); result.complete(); }, () => {\n    if (!progress.completed) {\n      setTimeout(() => {\n        result.complete();\n        progress.completed = true;\n      }, 0);\n    }\n  });\n\n  return result;\n}\n\nexport function parseLog(log: String): Promise<FlightLog> {\n  const lines = log.split('\\n');\n  const subject = new QuasiSubject<string>();\n  const parse = parseLogStream(subject);\n\n  const flightLog: FlightLog = {\n    metaData: {} as FlightLogMetaData,\n    rows: [],\n    infos: []\n  }\n  parse.subscribe((event) => {\n    // The metadata is updated as the file is parsed, so always grab the latest one.\n    flightLog.metaData = (event.meta) ? event.meta : flightLog.metaData;\n    if (event.row) {\n      flightLog.rows.push(event.row);\n    }\n    if (event.info) {\n      // @ts-ignore\n      flightLog.infos.push(event.info);\n    }\n  });\n  lines.forEach(l => subject.next(l));\n  subject.complete();\n\n  return new Promise<FlightLog>((resolve, reject) => {\n    parse.toPromise().then(() => resolve(flightLog)).catch((reason => reject(reason)));\n  });\n}\n\nfunction parseBody(lines: string[], sync?: boolean): Promise<FlightLogRow[]> {\n  const text = lines.join('\\n');\n  const options = {\n    delimiter: '\\t',\n    escape: null,\n    from: 1,\n    quote: null,\n    relax_column_count: true,\n  };\n\n  return new Promise((resolve, reject) => {\n    const onResults = (err: any, result: string[]) => {\n      if (err) {\n        return reject(err);\n      }\n\n      const [headers, ...rows] = result;\n\n      const logs = rows.map((row) => {\n        const log = {} as FlightLogRow;\n        for (let i = 0; i < headers.length; i++) {\n          const header = headers[i].trim() as FlightLogHeader;\n          let value: any = row[i];\n\n          if (INT_FIELDS.has(header)) {\n            value = parseInt(value, 10);\n          }\n\n          if (FLOAT_FIELDS.has(header)) {\n            value = parseFloat(value);\n          }\n\n          if (BOOL_FIELDS.has(header)) {\n            value = value !== '0';\n          }\n\n          if (DATE_FIELDS.has(header)) {\n            value = fromUtcDateStr(value);\n          }\n\n          log[header] = value;\n        }\n\n        return log;\n      });\n\n      resolve(logs);\n    };\n    if (sync) {\n      const results = syncParse(text, options);\n      onResults(undefined, results);\n    } else {\n      // @ts-ignore\n      parse(text, options, onResults);\n    }\n  });\n}\n\nfunction findMatch(search: string[], regex: RegExp, isNum?: boolean) {\n  let match;\n  for (let str of search) {\n    match = str.match(regex);\n    if (match) {\n      break;\n    }\n  }\n\n  if (!match) {\n    return isNum ? '0' : 'N/A';\n  }\n\n  return match[1];\n}\n\nfunction isValidDate(d: any) {\n  return d instanceof Date && !isNaN(d as any);\n}\n\nexport function fromUtcDateStr(utcDateStr: string) {\n  if (isValidDate(utcDateStr)) {\n    return utcDateStr as any as Date;\n  }\n  const isBadDate = !utcDateStr || !utcDateStr.trim().length || utcDateStr === 'N/A';\n  if (isBadDate) {\n    return null;\n  }\n  if (!/Z$/.test(utcDateStr)) {\n    utcDateStr = utcDateStr + '.000Z';\n  }\n  return new Date(utcDateStr);\n}\n\nfunction parseMetaData(headers: string[], footers: string[]): FlightLogMetaData {\n  const meta = [...headers, ...footers];\n  let end = findMatch(meta, META_REGEX.sessionEnd);\n  let elapsed = findMatch(meta, META_REGEX.elapsedTime);\n\n  // if we weren't able to parse an end date or an elapsed time from our footer (which is really just the last three\n  // lines of the log file), it's likely that we have a truncated log file. if that's the case, we can still salvage\n  // some valid data by parsing the date and elapsed time from the very last log row in the file, which is what we're\n  // doing below. it's pretty brittle, but it's preferred to having an invalid end date and a NaN elapsed time.\n  if ((end === 'N/A' || elapsed === 'N/A') && footers.length > 0) {\n    const lastLine = footers[footers.length - 1];\n    const pieces = lastLine.split('\\t');\n\n    // if we don't have at least two pieces, i don't know what is in `footer` so i'm just going to leave it alone\n    if (pieces.length >= 2) {\n      end = pieces[0];\n      elapsed = pieces[1];\n    }\n  }\n\n  return {\n    appVersion: findMatch(meta, META_REGEX.appVersion),\n    session: {\n      id: findMatch(meta, META_REGEX.sessionId),\n      start: fromUtcDateStr(findMatch(meta, META_REGEX.sessionStart)) as Date,\n      end: fromUtcDateStr(end),\n      elapsed: elapsed === 'N/A' ? 0 : parseFloat(elapsed),\n    },\n    device: {\n      model: findMatch(meta, META_REGEX.deviceModel),\n      os: findMatch(meta, META_REGEX.deviceOS).replace(/\\t/g, ' '),\n      platform: findMatch(meta, META_REGEX.platform),\n    },\n    aircraft: {\n      model: findMatch(meta, META_REGEX.aircraftModel),\n      name: findMatch(meta, META_REGEX.aircraftName),\n      firmware: findMatch(meta, META_REGEX.aircraftFirmware),\n    },\n    battery: {\n      chargeVolume: parseInt(findMatch(meta, META_REGEX.batteryChargeVolume, true), 10),\n      remainingLifePercent: parseInt(findMatch(meta, META_REGEX.batteryRemainingLife, true), 10),\n      discharges: parseInt(findMatch(meta, META_REGEX.batteryDischarges, true), 10),\n      cells: parseInt(findMatch(meta, META_REGEX.batteryCells, true), 10),\n      firmware: findMatch(meta, META_REGEX.batteryFirmware),\n      serialNumber: findMatch(meta, META_REGEX.batterySerialNumber),\n    },\n    flightController: {\n      serialNumber: findMatch(meta, META_REGEX.fcSerialNumber),\n      firmware: findMatch(meta, META_REGEX.fcFirmware),\n    },\n    gimbal: {\n      firmware: findMatch(meta, META_REGEX.gimbalFirmware),\n    },\n    remoteController: {\n      serialNumber: findMatch(meta, META_REGEX.rcSerialNumber),\n      firmware: findMatch(meta, META_REGEX.rcFirmware),\n    },\n    camera: {\n      serialNumber: findMatch(meta, META_REGEX.cameraSerialNumber),\n    },\n    user: {\n      userId: findMatch(meta, META_REGEX.userId),\n      organizationId: findMatch(meta, META_REGEX.organizationId),\n    },\n  };\n}\n\n/**\n * Parse out the given string and return an object if the string is JSON, return undefined otherwise.\n *\n * @param info\n */\nfunction parseJsonInfo(info: string): undefined|Array<object> {\n  if (!info) {\n    return undefined;\n  }\n  try {\n    return JSON.parse(info);\n  }\n  catch (e) {\n    return undefined;\n  }\n}\n"],"names":[],"mappings":"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","x_google_ignoreList":[1]}